# Two Sum

## 💡 最初の考察
- 素直に解こうと思うと、全件順番になめる感じ。
- 配列から順に一つ取り出し、一つ取り出した値以外の配列の値から配列を順に足していく。
- 配列の要素数が増えると、めちゃ遅くなる。
- $O(N^2)$

```python
class Solution:
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        for i, n in enumerate(nums):
            for j, m in enumerate(nums):
                if i == j:
                    continue

                if n + m == target:
                    return [i, j]
```

## 🤖 AI分析 & フィードバック
現在のコードでも正解（AC）は取れますが、制約の「要素数 $10^4$」を考えると、もう少しスマートにいきたいところ。

**💡 ヒント**
「相方（`target - n`）を一瞬で探すための道具」として、**ハッシュマップ（Pythonの辞書 dict）**を使う。
- 過去に見た数字を辞書に入れていく（`{数値: インデックス}`）。
- 今見ている数字 `n` に対して、`target - n` が辞書に存在するか確認する。
- 存在すれば、それが答え。
- これなら、二重ループ（$O(N^2)$）を**一重ループ（$O(N)$）**にまで短縮可能。

## ❓ 自分の疑問と深掘り
- **ごちゃつきに関する疑問**
    - ループを回しながらハッシュマップの作成と該当するものを探しているが、一旦 $O(N)$ でハッシュマップを作り切ってから、該当するものを探すのはあかんの？
    - → それでも解けるが、同じ数字が2回出てくる場合（例：`nums=[3,3], target=6`）に辞書の上書きが発生して工夫が必要になる。1パス（作りながら探す）なら、自分自身を重複して使うミスを自然に防げる。

- **本質の理解**
    - 1つが決まればもう一方は確実に決まる。順番に先頭から潰していく感じか？
    - 結局根本の思想は総当たりだけど、ハッシュマップというメモ帳を活用して1回の探索で済むようにしている？
    - → その通り。探索の「手間」をハッシュマップでショートカットしている。

## ✅ 修正後のコード（最適解）
```python
class Solution:
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        hash_map: dict[int, int] = {}

        for i, n in enumerate(nums):
            if target - n in hash_map:
                return [i, hash_map[target - n]]

            hash_map[n] = i
```

## 🤖 AIレビュー
この実装の素晴らしいポイント：
- **1パス（One-pass）解法**: ループを1回回しながら「チェック」と「保存」を同時に行っているため、無駄がない。
- **計算量の最適化**: $O(N^2)$ から $O(N)$ への劇的な改善。
- **型ヒント**: `hash_map: dict[int, int]` と型を明示している点も、実務レベルで丁寧な仕事。

- **Time Complexity**: $O(N)$
- **Space Complexity**: $O(N)$


- 毎回探しにいくのは面倒、どこかで簡単に索引できる一覧表のようなものがあればいいのに
- 未来のために、今をメモる
- 押してダメなら、引いてみる
  - AとBを足す考えの逆を考えてみる、a + b = Target -> a = Target -b -> aで探す 

---

## 🧠 ハッシュマップに辿り着くための思考回路

- **「探す」を「見るだけ」にしたい**
    - 毎回、教室の端から端まで「君、ターゲットの相方？」と聞いて回るのは面倒（$O(N^2)$）。
    - どこかに索引（インデックス）された一覧表があれば、一瞬で特定できるはず。
- **未来のために、今をメモる**
    - 今のループで見た数字は、後から来る数字の「相方」になるかもしれない。
    - 「あとで必要になるかも」という予見を持って、辞書という忘れ物センターに預けておく。
- **押してダメなら、引いてみる（逆算の思考）**
    - 「$a + b = Target$」となる組み合わせを全通り試す（足し算の思考）のは大変。
    - 「$a = Target - b$」と変形し、ターゲットを一点（$a$）に絞ってから、その $a$ が過去のメモにあるか探す。